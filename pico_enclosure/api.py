"""Web API Interface."""
import json

from .logging import logger, _exception_to_str

HTML_BASE = """<!DOCTYPE html>
<html>
    <style>
    </style>
    <head><title>pico print %(route)s</title></head>
    <body>
        %(body)s
    </body>
</html>
"""


class _StatusCode:
    def __init__(self, code, message):
        self.code = code
        self.message = message

    def __repr__(self):
        return f"{self.code} {self.message}"


class HTTP_STATUS_CODES:
    _200 = _StatusCode(200, "OK")
    _404 = _StatusCode(404, "PAGE NOT FOUND")
    _500 = _StatusCode(500, "INTERNAL SERVER ERROR")


class API:
    """An async API service."""

    def __init__(self, logger):
        self._routes = {}
        self._doc = ""
        self.route("/docs")(self.docs)
        self.logger = logger
        if self.logger.file_log:
            self.route("/logs")(self.logs)

    def route(self, route: str):
        """Decorator to manage the attaching functions to routes.

        Args:
            route: The API route to which the decorated function is attached

        """

        def _wrap_func(func):
            self._routes[route] = func
            self._doc += f'<h2><a href="{route}">{route}</h2>\n<hr>\n'
            return func

        return _wrap_func

    async def route_requests(self, reader, writer):
        """Route incoming requests.

        Args:
            reader:
            writer:

        """

        request = str(await reader.readline())
        while await reader.readline() != b"\r\n":  # Ignore headers
            pass

        # method, path, protocol
        _, request_path, _ = request.split(
            " "
        )  # Break apart "GET \this\path?arg=1 HTTP/1.1"
        parts = request_path.split("?")
        route = parts[0]

        if len(parts) == 2:
            params = dict(v.split("=") for v in parts[1].split("&"))
        else:
            params = None

        response_code = HTTP_STATUS_CODES._200
        log_method = self.logger.info

        result = None
        log_message = None
        try:
            result = await self._routes[route](**params or {})
        except KeyError:
            response_code = HTTP_STATUS_CODES._404
            log_method = self.logger.error
        except Exception as e:
            response_code = HTTP_STATUS_CODES._500
            log_method = self.logger.error
            log_message = _exception_to_str(e)
        finally:
            if result is None:
                result = "<h1>%s - %s</h1>%s%s" % (
                    response_code.code,
                    response_code.message,
                    log_message + "\n" if log_message else "",
                    "\n\n" + self._doc,
                )
            log_method(
                "%s:%s%s",
                *reader.get_extra_info("peername"),
                "\n" + log_message if log_message else "",
                api_route=route,
                api_status_code=response_code.code,
            )
            if isinstance(
                result,  # pyright: ignore [reportUnboundVariable]
                (dict, list),
            ):
                body = json.dumps(result)
                content_type = "application/json"
            else:
                body = HTML_BASE % {
                    "route": route,
                    "body": result,
                }
                content_type = "text/html"

            writer.write(
                "HTTP/1.0 %s\r\nContent-type: %s\r\n\r\n"
                % (
                    response_code,  # pyright: ignore [reportUnboundVariable]
                    content_type,
                )
            )
            writer.write(body)
            await writer.drain()
            await writer.wait_closed()

    async def logs(self):
        return "<table>" + self.logger.log_buffer.getvalue() + "</table>"

    async def docs(self):
        """Autogenerated documentation for available endpoints."""
        return self._doc


api = API(logger)
